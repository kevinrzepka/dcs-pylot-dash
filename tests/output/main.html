<!--
Copyright (c) 2025 Kevin Rzepka <kdev@posteo.com>
SPDX-License-Identifier: MIT
License-Filename: LICENSE
-->
<!--
Copyright (c) 2025 Kevin Rzepka <kdev@posteo.com>

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

-->
<!DOCTYPE html>
<html lang="en" class="h-100">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>DCSPylotDash</title>
    <style>

        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap');

        [data-bs-theme=dark] {
            color-scheme: dark;
            --bs-body-color: #dee2e6;
            --bs-body-color-rgb: 222, 226, 230;
            --bs-body-bg: #212529;
            --bs-body-bg-rgb: 33, 37, 41;
            --bs-emphasis-color: #fff;
            --bs-emphasis-color-rgb: 255, 255, 255;
            --bs-secondary-color: rgba(222, 226, 230, 0.75);
            --bs-secondary-color-rgb: 222, 226, 230;
            --bs-secondary-bg: #343a40;
            --bs-secondary-bg-rgb: 52, 58, 64;
            --bs-tertiary-color: rgba(222, 226, 230, 0.5);
            --bs-tertiary-color-rgb: 222, 226, 230;
            --bs-tertiary-bg: #2b3035;
            --bs-tertiary-bg-rgb: 43, 48, 53;
            --bs-primary-text-emphasis: #6ea8fe;
            --bs-secondary-text-emphasis: #a7acb1;
            --bs-success-text-emphasis: #75b798;
            --bs-info-text-emphasis: #6edff6;
            --bs-warning-text-emphasis: #ffda6a;
            --bs-danger-text-emphasis: #ea868f;
            --bs-light-text-emphasis: #f8f9fa;
            --bs-dark-text-emphasis: #dee2e6;
            --bs-primary-bg-subtle: #031633;
            --bs-secondary-bg-subtle: #161719;
            --bs-success-bg-subtle: #051b11;
            --bs-info-bg-subtle: #032830;
            --bs-warning-bg-subtle: #332701;
            --bs-danger-bg-subtle: #2c0b0e;
            --bs-light-bg-subtle: #343a40;
            --bs-dark-bg-subtle: #1a1d20;
            --bs-primary-border-subtle: #084298;
            --bs-secondary-border-subtle: #41464b;
            --bs-success-border-subtle: #0f5132;
            --bs-info-border-subtle: #087990;
            --bs-warning-border-subtle: #997404;
            --bs-danger-border-subtle: #842029;
            --bs-light-border-subtle: #495057;
            --bs-dark-border-subtle: #343a40;
            --bs-heading-color: inherit;
            --bs-link-color: #6ea8fe;
            --bs-link-hover-color: #8bb9fe;
            --bs-link-color-rgb: 110, 168, 254;
            --bs-link-hover-color-rgb: 139, 185, 254;
            --bs-code-color: #e685b5;
            --bs-highlight-color: #dee2e6;
            --bs-highlight-bg: #664d03;
            --bs-border-color: #495057;
            --bs-border-color-translucent: rgba(255, 255, 255, 0.15);
            --bs-form-valid-color: #75b798;
            --bs-form-valid-border-color: #75b798;
            --bs-form-invalid-color: #ea868f;
            --bs-form-invalid-border-color: #ea868f;
        }

        body {
            font-family: 'Roboto Mono', monospace;
            background: radial-gradient(circle at 20% 80%, rgba(0, 255, 0, 0.05) 0%, transparent 50%),
            radial-gradient(circle at 80% 20%, rgba(0, 221, 255, 0.05) 0%, transparent 50%),
            #0a0a0a;
        }

        .card-title, .card-subtitle {
            font-size: 2rem;
            font-weight: bold;
        }

        .data-value {
            font-size: 3rem;
            font-weight: bold;
            font-family: 'Roboto Mono', monospace;
            letter-spacing: 0.2rem;
        }

        .data-unit {
            font-weight: 700;
            font-size: 1.5rem;
        }


    </style>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
</head>
<body data-bs-theme="dark">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI"
        crossorigin="anonymous"></script>

<div id="root-container" class="container-fluid py-4">
    <div class="row" id="row-header">
        <h2 id="appTitle" class="text-center text-secondary data-value">DCSPylotDash</h2>
    </div>

    <div id="waitingMessage" class="alert alert-info" style="margin: 4rem" role="alert">
        Waiting for data... If you still see this message after a mission was started, please check the following
        locations for errors:
        <ul>
            <li>DCS log, usually at "C:\Users\&ltusername&gt\Saved Games\DCS\Logs\dcs.log"</li>
            <li>Your browser console, which is usually opened by pressing F12 to show the dev tools</li>
        </ul>
    </div>

    <div class="row g-4 m-2" id="row-default">
    </div>
</div>

<script>
    const dataHost = 'http://127.0.0.1';
    const dataPort = '52025';
    const dataUrl = `${dataHost}:${dataPort}`;

    const appTitle = 'DCSPylotDash';
    const appVersion = 'v0.0.0';
    document.title = `${appTitle} ${appVersion}`;
    document.getElementById('appTitle').innerText = `${appTitle} ${appVersion}`;

    const ID_ROOT_CONTAINER = 'root-container';
    const ID_ROW_DEFAULT = 'row-default';
    const ID_ROW_HEADER = 'row-header';

    /**
     * Key: Elements as created by {@link createContainer}, Value: Id of the data element
     * @type {Map<any, any>}
     */
    const containerToIdMap = new Map();

    /**
     *
     * @type {Map<any, any>}
     */
    const titleMap = new Map();
    titleMap.set('data.ias.kts', 'Airspeed');
    titleMap.set('data.mach', 'Mach number');
    titleMap.set('data.tas.kts', 'True airspeed');
    titleMap.set('data.heading.degrees', 'Heading (Degrees)');
    titleMap.set('data.altitude.msl.ft', 'Altitude (MSL)');
    titleMap.set('data.altitude.agl.ft', 'Altitude (AGL)');
    titleMap.set('data.fuel.internal.lbs', 'Fuel (total)');
    titleMap.set('data.arms.gun_rounds', 'Gun rounds');

    /**
     * For fields without a unit, this map should contain an entry with value ''
     * @type {Map<any, any>}
     */
    const unitMap = new Map();
    unitMap.set('data.ias.kts', 'kts');
    unitMap.set('data.mach', '');
    unitMap.set('data.tas.kts', 'kts');
    unitMap.set('data.heading.degrees', '°');
    unitMap.set('data.altitude.msl.ft', 'ft');
    unitMap.set('data.altitude.agl.ft', 'ft');
    unitMap.set('data.fuel.internal.lbs', 'lbs');
    unitMap.set('data.arms.gun_rounds', '');

    /**
     * Key: Dotted field name. Value: Number of fractional digits
     *
     * @type {Map<any, any>}
     */
    const decimalDigitsMap = new Map();
    decimalDigitsMap.set('data.ias.kts', '0');
    decimalDigitsMap.set('data.mach', '2');
    decimalDigitsMap.set('data.tas.kts', '0');
    decimalDigitsMap.set('data.heading.degrees', '0');
    decimalDigitsMap.set('data.altitude.msl.ft', '0');
    decimalDigitsMap.set('data.altitude.agl.ft', '0');
    decimalDigitsMap.set('data.fuel.internal.lbs', '0');
    decimalDigitsMap.set('data.arms.gun_rounds', '0');

    const positionMap = new Map();
    positionMap.set('data.ias.kts', [0, 0]);
    positionMap.set('data.mach', [0, 1]);
    positionMap.set('data.tas.kts', [0, 2]);
    positionMap.set('data.heading.degrees', [1, 0]);
    positionMap.set('data.altitude.msl.ft', [1, 1]);
    positionMap.set('data.altitude.agl.ft', [1, 2]);
    positionMap.set('data.fuel.internal.lbs', [3, 0]);
    positionMap.set('data.arms.gun_rounds', [4, 0]);

    /**
     * Key: Dotted field name. Value: Array of: {min: number, max: number, color: string}
     * @type {Map<any, any>}
     */
    const colorScaleMap = new Map();


    let busy = false;
    let firstDataReceived = false;
    const errorUpdateIntervalMs = 1000;
    let lastErrorTime = null;

    async function fetchData() {
        let data = null;
        const response = await fetch(dataUrl);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        data = await response.json();
        return data;
    }

    async function updateData() {
        if (busy) {
            return;
        }
        if (lastErrorTime !== null && new Date() - lastErrorTime < errorUpdateIntervalMs) {
            return;
        }
        busy = true;
        try {
            const data = await fetchData();
            processData(data);
            if (!firstDataReceived) {
                firstDataReceived = true;
                document.getElementById('waitingMessage').remove();
            }
        } catch (e) {
            lastErrorTime = new Date();
            console.error(e);
        } finally {
            busy = false;
        }
    }

    function createContainer(id, title) {
        const container = document.createElement('div');
        container.classList.add('col', 'col-md-6', 'col-lg-4', 'col-xl-3');
        const card = document.createElement('div');
        card.classList.add('card', 'h-100');
        const cardBody = document.createElement('div');
        cardBody.classList.add('card-body', 'text-center');
        const cardTitle = document.createElement('h4');
        cardTitle.classList.add('card-title', 'mb-2', 'text-body-secondary', 'text-uppercase');
        cardTitle.innerText = title;
        const cardValue = document.createElement('div');
        cardValue.classList.add('data-value', 'text-success', 'mb-1');
        cardValue.id = id;
        const cardUnit = document.createElement('small');
        cardUnit.classList.add('data-unit', 'text-body-secondary');
        cardUnit.innerText = getContainerUnit(id);

        container.appendChild(card);
        card.appendChild(cardBody);
        cardBody.appendChild(cardTitle);
        cardBody.appendChild(cardValue);
        cardBody.appendChild(cardUnit);
        return container
    }

    function createRow(id) {
        const row = document.createElement('div');
        row.id = id;
        row.classList.add('row', 'g-4', 'm-2');
        return row;
    }

    function getContainerName(id) {
        const plainId = getIdWithoutIndices(id);
        return titleMap.has(plainId) ? titleMap.get(plainId) : id;
    }

    function getContainerUnit(id) {
        const plainId = getIdWithoutIndices(id);
        return unitMap.has(plainId) ? unitMap.get(plainId) : 'N/A';
    }

    function getIdWithoutIndices(id) {
        const resultChunks = [];
        const chunks = id.split('.')
        for (const c of chunks) {
            if (!/^\d+$/.test(c)) {
                resultChunks.push(c);
            }
        }
        return resultChunks.join('.');
    }

    function elementExists(id) {
        return document.getElementById(id) !== null;
    }

    function appendToElement(elementId, child) {
        const element = document.getElementById(elementId);
        element.appendChild(child);
    }

    function createCard(fullName) {
        const title = getContainerName(fullName);
        return createContainer(fullName, title);
    }

    function createRowAndAppendToElement(parentFullName, rowId) {
        const row = createRow(rowId);
        appendToElement(parentFullName, row);
        return row;
    }

    function ensureDataRowsExistUpTo(row) {
        const rootContainer = document.getElementById(ID_ROOT_CONTAINER);
        const defaultRowElement = document.getElementById(ID_ROW_DEFAULT);
        let rowElement = null;
        for (let i = 0; i <= row; i++) {
            const rowId = `row-${i}`;
            if (!elementExists(rowId)) {
                rowElement = createRow(rowId);
                rootContainer.insertBefore(rowElement, defaultRowElement);
            } else {
                rowElement = document.getElementById(rowId);
            }
        }
        return rowElement;
    }

    function isEmpty(value) {
        if (value === null || value === undefined) {
            return true;
        }
        if (value instanceof Array) {
            return value.length === 0;
        }
        if (value instanceof String) {
            return value.length === 0;
        }
        return false;
    }

    function getColorscaleColor(fieldName, fieldValue) {
        if (!colorScaleMap.has(fieldName)) {
            return null;
        }
        if (fieldValue === null || fieldValue === undefined || !fieldValue instanceof Number) {
            console.warn(`Field value ${fieldValue} is not a valid colorscale value for field ${fieldName}`);
            return null;
        }
        const colorscale = colorScaleMap.get(fieldName);
        for (const entry of colorscale) {
            const min = entry.min;
            const max = entry.max;
            if (!isEmpty(min) && !isEmpty(max) && fieldValue >= min && fieldValue < max) {
                return entry.color;
            }
            if (!isEmpty(min) && isEmpty(max) && fieldValue >= min) {
                return entry.color;
            }
            if (isEmpty(min) && !isEmpty(max) && fieldValue < max) {
                return entry.color;
            }
        }
        return null;
    }

    function processData(data) {
        processDataNode(data, null, 'data', ID_ROW_DEFAULT);
    }

    function processDataNode(node, parentFullName, localName, appendToElementId) {
        let fullName = `${localName}`;
        if (!isEmpty(parentFullName)) {
            fullName = `${parentFullName}.${fullName}`;
        }
        for (let [key, value] of Object.entries(node)) {
            if (value instanceof Array) {
                const arrayFullName = `${fullName}.${key}`;
                for (let i = 0; i < value.length; i++) {
                    const rowId = `${arrayFullName}.${i}`;
                    if (!elementExists(rowId)) {
                        createRowAndAppendToElement(appendToElementId, rowId);
                    }
                    processDataNode(value[i], arrayFullName, i, rowId);
                }
            } else if (typeof value === 'object') {
                processDataNode(value, fullName, key, appendToElementId);
            } else {
                const leafFullName = `${fullName}.${key}`;
                if (!elementExists(leafFullName)) {
                    let row = document.getElementById(ID_ROW_DEFAULT);
                    const card = createCard(leafFullName);
                    if (positionMap.has(leafFullName)) {
                        const position = positionMap.get(leafFullName);
                        row = ensureDataRowsExistUpTo(position[0]);
                        const lastChild = row.children[row.childElementCount - 1];
                        let lastChildShouldBeMoved = false;
                        if (lastChild) {
                            const lastChildId = containerToIdMap.get(lastChild);
                            lastChildShouldBeMoved = lastChildId !== undefined && (!positionMap.has(lastChildId) || positionMap.get(lastChildId)[1] > position[1]);
                        }
                        if (row.childElementCount > position[1]) {
                            const child = row.children[position[1]];
                            row.insertBefore(card, child);
                        } else if (lastChildShouldBeMoved) {
                            row.insertBefore(card, lastChild);
                        } else {
                            appendToElement(row.id, card);
                        }
                    } else {
                        appendToElement(row.id, card);
                    }
                }
                const element = document.getElementById(leafFullName);
                if (element) {
                    let finalValue = value;
                    if (decimalDigitsMap.has(leafFullName)) {
                        finalValue = value.toFixed(decimalDigitsMap.get(leafFullName));
                    }
                    element.innerText = `${finalValue}`;
                    const color = getColorscaleColor(leafFullName, finalValue);
                    if (color !== null) {
                        element.classList.remove('text-success');
                    } else {
                        element.classList.add('text-success');
                    }
                    element.style.color = color;
                } else {
                    console.warn(`Element with id ${fullName} not found`);
                }
            }
        }
    }

    setInterval(updateData, 200);

</script>

</body>
</html>
